{"ast":null,"code":"import _slicedToArray from \"/Users/pokeoseu/Desktop/React-Self-Study/api-integrate/api/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nvar _jsxFileName = \"/Users/pokeoseu/Desktop/React-Self-Study/api-integrate/api/src/Users1.js\";\nimport React, { useState } from 'react'; // import axios from 'axios';\n// import {useAsync} from 'react-async';\n\nimport User1 from './User1';\nimport { useUsersState, useUsesrDispatch, getUsers } from './UsrsContext'; // async function getUsers() {//useAsync를 사용할때 callback으로 넣어줄 함수이다.\n//   const response = await axios.get('http://jsonplaceholder.typicode.com/users/');\n//   return response.data;\n// }//이부분은 파라미터로 받아오는것이 없기에 딱히 수정할것이없다.\n//LOADING,SUCCESS,ERRROR\n// function reducer(state,action){\n//   switch(action.type){\n//     case 'LOADING':\n//       return {\n//         loading:true,\n//         data:null,\n//         error:null\n//       }\n//     case 'SUCCESS':\n//       return {\n//         laoding:false,\n//         data:action.data,\n//         error:null\n//       }\n//     case 'ERROR':\n//       return {\n//         loading:false,\n//         data:null,\n//         error:action.error\n//       }\n//     default:\n//        throw new Error(`UnHandled action type :${action.type}`);\n//   }\n// }\n//useReducer 사용하여 요청에 대한 상태를 관리하였다.\n\nfunction Users1() {\n  // const [state, refetch] = useAsync(getUsers,[],true);//useAsync의두번째 파라미터와 세번째 파라미터를 넣는다.\n  //이렇게 하면 컴포넌트가 처음 시작할때 렌더링 되는 것을 생략해주는 것이다.\n  //useAsync을 통해서 요청에 대한 것들을 컴포넌트에서 처리하기때문에 코드가 간결해졌다.\n  const _useState = useState(null),\n        _useState2 = _slicedToArray(_useState, 2),\n        userId = _useState2[0],\n        setUserId = _useState2[1]; // const {data: users, error, isLoading,reload,run}=useAsync({//reload는 이전에 사용한 refech 와 같은 기능을 하는 것이다.\n  //   deferFn:getUsers\n  // })\n  //이전에 버튼을 눌러야 데이터를 불러오고 싶을 경우에 react-async 라이브러리에선\n  //deferFn을 사용한다. run 이라는 파라미터를 불러온다.\n  //reload대신에 run 으로 대체한다.\n\n\n  const state = useUsersState();\n  const dispatch = useUsesrDispatch();\n  const _state$users = state.users,\n        loading = _state$users.loading,\n        users = _state$users.data,\n        error = _state$users.error;\n\n  const fetchData = () => {\n    getUsers(dispatch);\n  }; // const [state,dispatch]=useReducer(reducer,{\n  //   loading:false,\n  //   data:null,\n  //   error:null\n  // })\n  // const fetchUsers = async () => {//useEffect을 사용하여 컴포넌트가 가장 처음에 렌더링이 될때 fetchUsers라는 함수를 호출한다.\n  //   dispatch({type:'LOADING'});\n  //   try {\n  //     const response = await axios.get('http://jsonplaceholder.typicode.com/users/');\n  //     dispatch({type:'SUCCESS',data:response.data})\n  //   } catch (e) {\n  //     dispatch({type:'ERROR',error:e})\n  //     console.log(e.response.status);\n  //   }\n  // }\n  // useEffect(() => {\n  //   fetchUsers();\n  // }, []);\n  // const { loading, data: users, error } = state;\n  //그다음에는 세가지 상태에 따라 다른 값을 렌더링 할 것이다.\n\n\n  if (loading) return React.createElement(\"div\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 83\n    },\n    __self: this\n  }, \"\\uB85C\\uB529\\uC911...\");\n  if (error) return React.createElement(\"div\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 84\n    },\n    __self: this\n  }, \"\\uC5D0\\uB7EC \\uBC1C\\uC0DD\\uD588\\uC2B5\\uB2C8\\uB2E4.\"); // if (!users) return null;//users에 제대로된 값이 들어가지않았을때\n\n  if (!users) return React.createElement(\"button\", {\n    onClick: fetchData,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 86\n    },\n    __self: this\n  }, \"\\uBD88\\uB7EC\\uC624\\uAE30\"); //\n  //이렇게 버튼을 클릭해야만 데이터를 가져온다.\n  //users에 제대로된값이 들어갔을 경우에\n\n  return React.createElement(React.Fragment, null, React.createElement(\"ul\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 92\n    },\n    __self: this\n  }, users.map(user => React.createElement(\"li\", {\n    key: user.id,\n    onClick: () => setUserId(user.id),\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 93\n    },\n    __self: this\n  }, user.username, \"(\", user.name, \")\"))), React.createElement(\"button\", {\n    onClick: fetchData,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 98\n    },\n    __self: this\n  }, \"\\uB2E4\\uC2DC\\uBD88\\uB7EC\\uC624\\uAE30\"), userId && React.createElement(User1, {\n    id: userId,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 99\n    },\n    __self: this\n  }));\n}\n\nexport default Users1; // 지금의 경우에는 컴포넌트가 처음 렌더링되는 시점에만 데이터 요청이 이뤄지고있다.\n// 1.특정 버튼을 눌러야만 렌더링을 시작하고시파면 어떻게 해야할까?이를 위해서 useAysnc의 세번째 파라미터를 설정한다.\n// 2.우리가 api함수를 호출할때 특정 파라미터가 필요할때 어떻게 하는 지 알아보자!","map":{"version":3,"sources":["/Users/pokeoseu/Desktop/React-Self-Study/api-integrate/api/src/Users1.js"],"names":["React","useState","User1","useUsersState","useUsesrDispatch","getUsers","Users1","userId","setUserId","state","dispatch","users","loading","data","error","fetchData","map","user","id","username","name"],"mappings":";;AAAA,OAAOA,KAAP,IAAcC,QAAd,QAA6B,OAA7B,C,CACA;AACA;;AACA,OAAOC,KAAP,MAAkB,SAAlB;AACA,SAASC,aAAT,EAAwBC,gBAAxB,EAA0CC,QAA1C,QAA0D,eAA1D,C,CAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA,SAASC,MAAT,GAAkB;AAChB;AACA;AACA;AAHgB,oBAKSL,QAAQ,CAAC,IAAD,CALjB;AAAA;AAAA,QAKTM,MALS;AAAA,QAKFC,SALE,kBAMhB;AACA;AACA;AACA;AACA;AACA;;;AAEA,QAAMC,KAAK,GAACN,aAAa,EAAzB;AACA,QAAMO,QAAQ,GAACN,gBAAgB,EAA/B;AAdgB,uBAgBkBK,KAAK,CAACE,KAhBxB;AAAA,QAgBTC,OAhBS,gBAgBTA,OAhBS;AAAA,QAgBID,KAhBJ,gBAgBDE,IAhBC;AAAA,QAgBUC,KAhBV,gBAgBUA,KAhBV;;AAkBhB,QAAMC,SAAS,GAAC,MAAI;AAClBV,IAAAA,QAAQ,CAACK,QAAD,CAAR;AACD,GAFD,CAlBgB,CAsBhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAIE,OAAJ,EAAa,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6BAAP;AACb,MAAIE,KAAJ,EAAW,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,0DAAP,CA5CK,CA6ChB;;AACA,MAAI,CAACH,KAAL,EAAY,OAAO;AAAQ,IAAA,OAAO,EAAEI,SAAjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gCAAP,CA9CI,CA8C6C;AAC7D;AAEA;;AACA,SACE,0CACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACGJ,KAAK,CAACK,GAAN,CAAUC,IAAI,IAAI;AAAI,IAAA,GAAG,EAAEA,IAAI,CAACC,EAAd;AAAkB,IAAA,OAAO,EAAE,MAAIV,SAAS,CAACS,IAAI,CAACC,EAAN,CAAxC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAChBD,IAAI,CAACE,QADW,OACAF,IAAI,CAACG,IADL,MAAlB,CADH,CADF,EAOE;AAAQ,IAAA,OAAO,EAAEL,SAAjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,4CAPF,EAQGR,MAAM,IAAI,oBAAC,KAAD;AAAO,IAAA,EAAE,EAAEA,MAAX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IARb,CADF;AAaD;;AACD,eAAeD,MAAf,C,CACA;AACA;AACA","sourcesContent":["import React,{useState} from 'react';\n// import axios from 'axios';\n// import {useAsync} from 'react-async';\nimport User1 from './User1';\nimport { useUsersState, useUsesrDispatch, getUsers } from './UsrsContext';\n\n// async function getUsers() {//useAsync를 사용할때 callback으로 넣어줄 함수이다.\n//   const response = await axios.get('http://jsonplaceholder.typicode.com/users/');\n//   return response.data;\n\n// }//이부분은 파라미터로 받아오는것이 없기에 딱히 수정할것이없다.\n\n//LOADING,SUCCESS,ERRROR\n// function reducer(state,action){\n//   switch(action.type){\n//     case 'LOADING':\n//       return {\n//         loading:true,\n//         data:null,\n//         error:null\n//       }\n//     case 'SUCCESS':\n//       return {\n//         laoding:false,\n//         data:action.data,\n//         error:null\n//       }\n//     case 'ERROR':\n//       return {\n//         loading:false,\n//         data:null,\n//         error:action.error\n//       }\n//     default:\n//        throw new Error(`UnHandled action type :${action.type}`);\n\n//   }\n// }\n//useReducer 사용하여 요청에 대한 상태를 관리하였다.\nfunction Users1() {\n  // const [state, refetch] = useAsync(getUsers,[],true);//useAsync의두번째 파라미터와 세번째 파라미터를 넣는다.\n  //이렇게 하면 컴포넌트가 처음 시작할때 렌더링 되는 것을 생략해주는 것이다.\n  //useAsync을 통해서 요청에 대한 것들을 컴포넌트에서 처리하기때문에 코드가 간결해졌다.\n\n  const [userId,setUserId]=useState(null);\n  // const {data: users, error, isLoading,reload,run}=useAsync({//reload는 이전에 사용한 refech 와 같은 기능을 하는 것이다.\n  //   deferFn:getUsers\n  // })\n  //이전에 버튼을 눌러야 데이터를 불러오고 싶을 경우에 react-async 라이브러리에선\n  //deferFn을 사용한다. run 이라는 파라미터를 불러온다.\n  //reload대신에 run 으로 대체한다.\n\n  const state=useUsersState();\n  const dispatch=useUsesrDispatch();\n\n  const {loading,data:users,error}= state.users;\n\n  const fetchData=()=>{\n    getUsers(dispatch);\n  }\n\n  // const [state,dispatch]=useReducer(reducer,{\n  //   loading:false,\n  //   data:null,\n  //   error:null\n  // })\n  // const fetchUsers = async () => {//useEffect을 사용하여 컴포넌트가 가장 처음에 렌더링이 될때 fetchUsers라는 함수를 호출한다.\n  //   dispatch({type:'LOADING'});\n  //   try {\n  //     const response = await axios.get('http://jsonplaceholder.typicode.com/users/');\n  //     dispatch({type:'SUCCESS',data:response.data})\n\n  //   } catch (e) {\n  //     dispatch({type:'ERROR',error:e})\n  //     console.log(e.response.status);\n  //   }\n  // }\n  // useEffect(() => {\n  //   fetchUsers();\n  // }, []);\n  // const { loading, data: users, error } = state;\n  //그다음에는 세가지 상태에 따라 다른 값을 렌더링 할 것이다.\n  if (loading) return <div>로딩중...</div>\n  if (error) return <div>에러 발생했습니다.</div>\n  // if (!users) return null;//users에 제대로된 값이 들어가지않았을때\n  if (!users) return <button onClick={fetchData}>불러오기</button>;//\n  //이렇게 버튼을 클릭해야만 데이터를 가져온다.\n\n  //users에 제대로된값이 들어갔을 경우에\n  return (\n    <>\n      <ul>\n        {users.map(user => <li key={user.id} onClick={()=>setUserId(user.id)}>\n          {user.username}({user.name})\n  </li>)}\n      </ul>\n      {/* <button onClick={fetchUsers}>다시불러오기</button>*버튼을 눌렀을때 특정 api를 다시 불러오는 방법 */}\n      <button onClick={fetchData}>다시불러오기</button>{/**버튼을 눌렀을때 특정 api를 다시 불러오는 방법*/}\n      {userId && <User1 id={userId}/>}\n\n    </>\n  )\n}\nexport default Users1;\n// 지금의 경우에는 컴포넌트가 처음 렌더링되는 시점에만 데이터 요청이 이뤄지고있다.\n// 1.특정 버튼을 눌러야만 렌더링을 시작하고시파면 어떻게 해야할까?이를 위해서 useAysnc의 세번째 파라미터를 설정한다.\n// 2.우리가 api함수를 호출할때 특정 파라미터가 필요할때 어떻게 하는 지 알아보자!\n\n"]},"metadata":{},"sourceType":"module"}