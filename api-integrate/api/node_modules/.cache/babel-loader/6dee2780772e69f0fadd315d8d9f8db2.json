{"ast":null,"code":"import _objectSpread from \"/Users/pokeoseu/Desktop/React-Self-Study/api-integrate/api/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nexport default function createAsyncDispatcher(type, promiseFn) {\n  const SUCCESS = `${type}_SUCCESS`;\n  const ERROR = `${type}_ERROR`;\n\n  async function actionHandler(dispatch, ...rest) {\n    dispatch({\n      type\n    });\n\n    try {\n      const data = await promiseFn(...rest);\n      dispatch({\n        type: SUCCESS,\n        data\n      });\n    } catch (e) {\n      dispatch({\n        type: ERROR,\n        error: e\n      });\n    }\n  }\n\n  return actionHandler; //createAsyncDispatcher의 역할은 actionHandler함수를 만들어서 내보내는 일이다.\n}\nexport const initialAsyncState = {\n  loading: false,\n  data: null,\n  error: null\n};\nconst loadingState = {\n  loading: true,\n  data: null,\n  error: null\n}; //로딩 중일때 는 이 객체가 기본 값을대체한다.\n\nconst success = data => ({\n  loading: false,\n  data,\n  error: null\n});\n\nconst error = e => ({\n  laoding: false,\n  data: null,\n  error: e\n});\n\nexport function createAsyncHandler(type, key) {\n  //type은 action타입을 의미하고 key는 상태(initialState)안의 키의 값(users,user)을의미\n  const SUCCESS = `${type}_SUCCESS`;\n  const ERROR = `${type}_ERROR`;\n\n  function handler(state, action) {\n    //hander함수를 만들고 이함수를 reducer에서 호출해 주겠다.\n    switch (action.type) {\n      case type:\n        return _objectSpread({}, state, {\n          //기존의 상태,즉 불변성을 유지하기위해서 사용,user의 값을 바꿀때 users의 값은 그대로 하기 위해서\n          [key]: loadingState\n        });\n\n      case SUCCESS:\n        return _objectSpread({}, state, {\n          [key]: success(action.data)\n        });\n\n      case ERROR:\n        return _objectSpread({}, state, {\n          [key]: error(action.error)\n        });\n\n      default:\n        return state;\n    }\n  }\n\n  return handler;\n}","map":{"version":3,"sources":["/Users/pokeoseu/Desktop/React-Self-Study/api-integrate/api/src/asyncActionUtils.js"],"names":["createAsyncDispatcher","type","promiseFn","SUCCESS","ERROR","actionHandler","dispatch","rest","data","e","error","initialAsyncState","loading","loadingState","success","laoding","createAsyncHandler","key","handler","state","action"],"mappings":";AAAA,eAAe,SAASA,qBAAT,CAA+BC,IAA/B,EAAqCC,SAArC,EAAgD;AAC7D,QAAMC,OAAO,GAAI,GAAEF,IAAK,UAAxB;AACA,QAAMG,KAAK,GAAI,GAAEH,IAAK,QAAtB;;AACA,iBAAeI,aAAf,CAA6BC,QAA7B,EAAuC,GAAGC,IAA1C,EAAgD;AAC9CD,IAAAA,QAAQ,CAAC;AAAEL,MAAAA;AAAF,KAAD,CAAR;;AACA,QAAI;AACF,YAAMO,IAAI,GAAG,MAAMN,SAAS,CAAC,GAAGK,IAAJ,CAA5B;AACAD,MAAAA,QAAQ,CAAC;AACPL,QAAAA,IAAI,EAAEE,OADC;AAEPK,QAAAA;AAFO,OAAD,CAAR;AAID,KAND,CAME,OAAOC,CAAP,EAAU;AACVH,MAAAA,QAAQ,CAAC;AACPL,QAAAA,IAAI,EAAEG,KADC;AAEPM,QAAAA,KAAK,EAAED;AAFA,OAAD,CAAR;AAKD;AACF;;AACD,SAAOJ,aAAP,CAnB6D,CAmBxC;AAEtB;AACD,OAAO,MAAMM,iBAAiB,GAAG;AAC/BC,EAAAA,OAAO,EAAE,KADsB;AAE/BJ,EAAAA,IAAI,EAAE,IAFyB;AAG/BE,EAAAA,KAAK,EAAE;AAHwB,CAA1B;AAMP,MAAMG,YAAY,GAAG;AACnBD,EAAAA,OAAO,EAAE,IADU;AAEnBJ,EAAAA,IAAI,EAAE,IAFa;AAGnBE,EAAAA,KAAK,EAAE;AAHY,CAArB,C,CAIE;;AACF,MAAMI,OAAO,GAAIN,IAAD,KAAW;AACzBI,EAAAA,OAAO,EAAE,KADgB;AAEzBJ,EAAAA,IAFyB;AAGzBE,EAAAA,KAAK,EAAE;AAHkB,CAAX,CAAhB;;AAKA,MAAMA,KAAK,GAAGD,CAAC,KAAK;AAClBM,EAAAA,OAAO,EAAE,KADS;AAElBP,EAAAA,IAAI,EAAE,IAFY;AAGlBE,EAAAA,KAAK,EAAED;AAHW,CAAL,CAAf;;AAMA,OAAO,SAASO,kBAAT,CAA4Bf,IAA5B,EAAkCgB,GAAlC,EAAuC;AAAC;AAC7C,QAAMd,OAAO,GAAI,GAAEF,IAAK,UAAxB;AACA,QAAMG,KAAK,GAAI,GAAEH,IAAK,QAAtB;;AAEA,WAASiB,OAAT,CAAiBC,KAAjB,EAAwBC,MAAxB,EAAgC;AAAC;AAC/B,YAAQA,MAAM,CAACnB,IAAf;AACE,WAAKA,IAAL;AACE,iCACKkB,KADL;AACW;AACT,WAACF,GAAD,GAAOJ;AAFT;;AAIF,WAAKV,OAAL;AACE,iCACKgB,KADL;AAEE,WAACF,GAAD,GAAOH,OAAO,CAACM,MAAM,CAACZ,IAAR;AAFhB;;AAIF,WAAKJ,KAAL;AACE,iCACKe,KADL;AAEE,WAACF,GAAD,GAAOP,KAAK,CAACU,MAAM,CAACV,KAAR;AAFd;;AAIF;AACE,eAAOS,KAAP;AAjBJ;AAmBD;;AACH,SAAOD,OAAP;AACC","sourcesContent":["export default function createAsyncDispatcher(type, promiseFn) {\n  const SUCCESS = `${type}_SUCCESS`;\n  const ERROR = `${type}_ERROR`;\n  async function actionHandler(dispatch, ...rest) {\n    dispatch({ type });\n    try {\n      const data = await promiseFn(...rest);\n      dispatch({\n        type: SUCCESS,\n        data\n      })\n    } catch (e) {\n      dispatch({\n        type: ERROR,\n        error: e\n      })\n\n    }\n  }\n  return actionHandler;//createAsyncDispatcher의 역할은 actionHandler함수를 만들어서 내보내는 일이다.\n\n}\nexport const initialAsyncState = {\n  loading: false,\n  data: null,\n  error: null\n};\n\nconst loadingState = {\n  loading: true,\n  data: null,\n  error: null\n};//로딩 중일때 는 이 객체가 기본 값을대체한다.\nconst success = (data) => ({\n  loading: false,\n  data,\n  error: null\n});\nconst error = e => ({\n  laoding: false,\n  data: null,\n  error: e\n})\n\nexport function createAsyncHandler(type, key) {//type은 action타입을 의미하고 key는 상태(initialState)안의 키의 값(users,user)을의미\n  const SUCCESS = `${type}_SUCCESS`;\n  const ERROR = `${type}_ERROR`;\n\n  function handler(state, action) {//hander함수를 만들고 이함수를 reducer에서 호출해 주겠다.\n    switch (action.type) {\n      case type:\n        return {\n          ...state,//기존의 상태,즉 불변성을 유지하기위해서 사용,user의 값을 바꿀때 users의 값은 그대로 하기 위해서\n          [key]: loadingState\n        }\n      case SUCCESS:\n        return {\n          ...state,\n          [key]: success(action.data)\n        }\n      case ERROR:\n        return {\n          ...state,\n          [key]: error(action.error)\n        }\n      default:\n        return state;\n    }\n  }\nreturn handler;\n}\n"]},"metadata":{},"sourceType":"module"}