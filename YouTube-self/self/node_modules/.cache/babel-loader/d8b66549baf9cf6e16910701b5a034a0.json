{"ast":null,"code":"var _jsxFileName = \"/Users/pokeoseu/Desktop/React-Self-Study/YouTube-self/self/src/Main.js\";\nimport React from 'react';\nimport './App.css';\nimport axios from 'axios';\nimport Nav from './component/Nav/Nav';\nimport SearchBar from './component/SearchBar/SearchBar';\nimport InfiniteScroll from 'react-infinite-scroller';\nimport uuid from 'uuid';\nimport { spinner1 } from './component/images/';\nimport VideoList from './component/VideoList/VideoList';\nimport qs from 'qs';\nimport { withRouter } from 'react-router-dom';\nimport { debounce } from 'lodash';\nimport { connect } from 'react-redux';\nimport { bindActionCreators } from 'redux';\nimport { updateQuery } from './actions';\n\nclass Main extends React.Component {\n  constructor(props) {\n    super(props);\n    this._getYoutubeData = debounce(async (query, isChanged) => {\n      //getYoutubeData변수로 사용하기 위해서 함수 전체를 debounce로 하고 클래스 필드로 정의했다.\n      // if (this.props.query !== query) {\n      // this.setState(this.defaultState)\n      // setTimeout(() => \n      // this.props.history.push(`/results?search_query=${query}`), 0)\n      // return;\n      // }\n      // if (this.props.query !== query) {\n      //   setTimeout(() => \n      //   this.props.history.push(`/results?search_query=${query}`), 0)\n      //   this.setState(this.defaultState);\n      // }\n      // this.props.updateQuery(query)//props로 받아야함 provider가 받아왔기때문에 하위에서 props로 받아서한다.\n      try {\n        if (isChanged) {\n          this.setState(this.defaultState);\n        }\n\n        if (!query) return;\n        const nextPageToken = this.state.nextPageToken;\n        const params = {\n          key: process.env.REACT_APP_YOUTUBE_API_KEY,\n          q: query,\n          part: \"snippet\",\n          maxResults: 10,\n          pageToken: nextPageToken\n        };\n\n        const _ref = await axios.get(`https://www.googleapis.com/youtube/v3/search`, {\n          params\n        }),\n              data = _ref.data; //실행이 안되게 되면 this.setState는 실행이 안된다.\n\n\n        this.setState({\n          videos: [...this.state.videos, ...data.items],\n          // query,\n          nextPageToken: data.nextPageToken\n        }); // this.props.updateQuery(query)//getYOUTUBEdata하고 나서  updateQuery을 실행함, props로 받아야함 provider가 받아왔기때문에 하위에서 props로 받아서한다.\n      } catch (e) {}\n    }, 500);\n    Object.getOwnPropertyNames(Main.prototype).forEach(key => this[key] = this[key].bind(this));\n    this.state = {\n      videos: [],\n      // query: this.props.query,//reducer안에 정의된query\n      nextPageToken: null\n    };\n    this.defaultState = this.state;\n  }\n\n  getYoutubeData(query) {\n    let isChanged = false;\n\n    if (this.props.query !== query) {\n      isChanged = true;\n      this.props.updateQuery(query);\n    }\n\n    this._getYoutubeData(query, isChanged);\n  }\n\n  componentDidMount() {\n    //처음, 뒤로 를 누렀을때 실행됨 ,렌더링된 이후 실행 ,주소값이 바뀔때 마다 실행되지는 않는다.\n    const props = this.props;\n\n    if (props.location) {\n      //props는 route 가 주입해주는 값, props.location 정의되었을 경우에만 실행 /withRouter가 props을 주입하기에 /정의 된었는지 체크\n      const _qs$parse = qs.parse(props.location.search),\n            search_query = _qs$parse.search_query; //props.location이 정의되지않으면 undefined이다.\n\n\n      if (search_query) this.getYoutubeData(search_query || ''); //setState 로 설정하는 것이 아닌 리덕스를 사용하지않고 완결되는 코드를 위해 이렇게 바꿈,\n      //encodeUriComponet 입력한 한글 쿼리를 문자열로 바꿈\n    }\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    //모든 상태 변화를 감지한다.this의 props가 하나라도 바뀌거나 this.state의 값이 하나라도 바뀌게 되면 실행딘다.기존의 값들을 가지고있다.(이전에  업데이트 되기 전에 props)\n    const props = this.props; //이제 업데이트된 props\n\n    if (props.location) {\n      //작은 변화에도 실행되는 함수이다.\n      // if(prevState.query !== this.state.query)//이전 상태를 가지고있는 상태\n      const _qs$parse2 = qs.parse(props.location.search),\n            search_query = _qs$parse2.search_query; //업데이트 되어있는 ,props.location.search가 기준이된다. 검색주소에 있는 query String\n\n\n      const _qs$parse3 = qs.parse(prevProps.location.search),\n            prev = _qs$parse3.search_query; //search_query:pre로 renaming 구분하기 위해서\n\n\n      if (search_query !== prev) {\n        //업데이트 되고자하는 함수에 대해서만 조건을 해야한다.\n        this.getYoutubeData(search_query || '');\n      } // if(props.query != prev.query){\n      //   this.getYoutubeData(search_query || '')\n      // }\n\n    }\n  } //componentDidMount,componentDidUpdate에서 주소가 바뀌면 자동으로 감지하기때문에 다른 곳에 서 getYPUTUBEdata가 필요가 없다. 검색어가 바뀌면  주소도 같이 바뀌기 때문에\n\n\n  render() {\n    return React.createElement(\"div\", {\n      className: \"App\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 113\n      },\n      __self: this\n    }, React.createElement(Nav, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 114\n      },\n      __self: this\n    }, React.createElement(SearchBar, {\n      onSearchVideos: e => {\n        this.props.history.push(`/results?search_query=${e}`); // this.props.updateQuery(v);//e.target.value\n      },\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 115\n      },\n      __self: this\n    })), React.createElement(InfiniteScroll // loadMore={() => this.getYoutubeData(this.props.query)}\n    , {\n      hasMore: !!this.state.nextPageToken,\n      loader: React.createElement(\"div\", {\n        key: uuid.v4(),\n        className: \"loader\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 126\n        },\n        __self: this\n      }, React.createElement(\"img\", {\n        src: spinner,\n        alt: \"loading\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 127\n        },\n        __self: this\n      })),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 122\n      },\n      __self: this\n    }, React.createElement(VideoList, Object.assign({}, this.state, {\n      onVideoSelect: selectedVideo => this.props.history.push(`/watch?v=${selectedVideo}`),\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 131\n      },\n      __self: this\n    }))));\n  }\n\n}\n\nfunction mapStateToprops(state) {\n  return {\n    query: state.videos.query\n  };\n}\n\nfunction mapDispatchToProps(dispatch) {\n  return bindActionCreators({\n    //무조건 aciton에 있는 함수를 가져옴\n    updateQuery\n  }, dispatch);\n}\n\nexport default withRouter(connect(mapStateToprops, mapDispatchToProps)(Main)); //\n//history.push 이동하지않고 주소만 바뀌어보이는 것,브라우저 히스토리에 추가가 되기만 한다. 주소이동x\n//window.location.href 실제 이동","map":{"version":3,"sources":["/Users/pokeoseu/Desktop/React-Self-Study/YouTube-self/self/src/Main.js"],"names":["React","axios","Nav","SearchBar","InfiniteScroll","uuid","spinner1","VideoList","qs","withRouter","debounce","connect","bindActionCreators","updateQuery","Main","Component","constructor","props","_getYoutubeData","query","isChanged","setState","defaultState","nextPageToken","state","params","key","process","env","REACT_APP_YOUTUBE_API_KEY","q","part","maxResults","pageToken","get","data","videos","items","e","Object","getOwnPropertyNames","prototype","forEach","bind","getYoutubeData","componentDidMount","location","parse","search","search_query","componentDidUpdate","prevProps","prevState","prev","render","history","push","v4","spinner","selectedVideo","mapStateToprops","mapDispatchToProps","dispatch"],"mappings":"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","sourcesContent":["import React from 'react';\nimport './App.css';\nimport axios from 'axios';\nimport Nav from './component/Nav/Nav';\nimport SearchBar from './component/SearchBar/SearchBar';\nimport InfiniteScroll from 'react-infinite-scroller';\nimport uuid from 'uuid';\nimport { spinner1 } from './component/images/'\nimport VideoList from './component/VideoList/VideoList';\n\nimport qs from 'qs';\nimport { withRouter } from 'react-router-dom';\n\nimport {debounce} from 'lodash';\n\nimport { connect } from 'react-redux';\nimport { bindActionCreators } from 'redux';\nimport { updateQuery } from './actions';\n\nclass Main extends React.Component {\n  constructor(props) {\n    super(props);\n\n    Object.getOwnPropertyNames(Main.prototype).forEach(\n      key => (this[key] = this[key].bind(this))\n    );\n    this.state = {\n      videos: [],\n      // query: this.props.query,//reducer안에 정의된query\n      nextPageToken: null\n    };\n    this.defaultState = this.state;\n  }\n\n  _getYoutubeData = debounce(async (query,isChanged) => {//getYoutubeData변수로 사용하기 위해서 함수 전체를 debounce로 하고 클래스 필드로 정의했다.\n    \n      // if (this.props.query !== query) {\n      // this.setState(this.defaultState)\n      // setTimeout(() => \n      // this.props.history.push(`/results?search_query=${query}`), 0)\n      // return;\n    // }\n    // if (this.props.query !== query) {\n    //   setTimeout(() => \n    //   this.props.history.push(`/results?search_query=${query}`), 0)\n    //   this.setState(this.defaultState);\n    // }\n    // this.props.updateQuery(query)//props로 받아야함 provider가 받아왔기때문에 하위에서 props로 받아서한다.\n\n    try {\n      if(isChanged ){\n        this.setState(this.defaultState);\n      }\n      if(!query)return;\n\n      const { nextPageToken } = this.state;\n      const params = {\n        key: process.env.REACT_APP_YOUTUBE_API_KEY,\n        q: query,\n        part: \"snippet\",\n        maxResults: 10,\n        pageToken: nextPageToken\n      };\n      const { data } = await axios.get(\n        `https://www.googleapis.com/youtube/v3/search`,\n        { params }\n      )//실행이 안되게 되면 this.setState는 실행이 안된다.\n      \n      this.setState({\n        videos:[...this.state.videos, ...data.items],\n        // query,\n        nextPageToken: data.nextPageToken\n      });\n      // this.props.updateQuery(query)//getYOUTUBEdata하고 나서  updateQuery을 실행함, props로 받아야함 provider가 받아왔기때문에 하위에서 props로 받아서한다.\n    }catch (e){}\n  },500);\n\n  getYoutubeData(query){\n    let isChanged=false\n    if (this.props.query !== query) {\n      isChanged=true;\n      this.props.updateQuery(query);\n    }\n    this._getYoutubeData(query,isChanged)\n  }\n\n  componentDidMount() {//처음, 뒤로 를 누렀을때 실행됨 ,렌더링된 이후 실행 ,주소값이 바뀔때 마다 실행되지는 않는다.\n    const { props } = this\n    if (props.location) {//props는 route 가 주입해주는 값, props.location 정의되었을 경우에만 실행 /withRouter가 props을 주입하기에 /정의 된었는지 체크\n      const { search_query } = qs.parse(props.location.search)//props.location이 정의되지않으면 undefined이다.\n      if(search_query) this.getYoutubeData(search_query || '')//setState 로 설정하는 것이 아닌 리덕스를 사용하지않고 완결되는 코드를 위해 이렇게 바꿈,\n      //encodeUriComponet 입력한 한글 쿼리를 문자열로 바꿈\n    }\n  }\n\n  componentDidUpdate(prevProps,prevState){//모든 상태 변화를 감지한다.this의 props가 하나라도 바뀌거나 this.state의 값이 하나라도 바뀌게 되면 실행딘다.기존의 값들을 가지고있다.(이전에  업데이트 되기 전에 props)\n    const { props }=this; //이제 업데이트된 props\n    if(props.location){//작은 변화에도 실행되는 함수이다.\n      // if(prevState.query !== this.state.query)//이전 상태를 가지고있는 상태\n      const {search_query }=qs.parse(props.location.search)//업데이트 되어있는 ,props.location.search가 기준이된다. 검색주소에 있는 query String\n      const { search_query:prev } =qs.parse(prevProps.location.search)//search_query:pre로 renaming 구분하기 위해서\n      if(search_query !==prev){//업데이트 되고자하는 함수에 대해서만 조건을 해야한다.\n        this.getYoutubeData(search_query || '')        \n      }\n      // if(props.query != prev.query){\n      //   this.getYoutubeData(search_query || '')\n      // }\n    }\n  }\n  //componentDidMount,componentDidUpdate에서 주소가 바뀌면 자동으로 감지하기때문에 다른 곳에 서 getYPUTUBEdata가 필요가 없다. 검색어가 바뀌면  주소도 같이 바뀌기 때문에\n  render() {\n    return (\n      <div className=\"App\">\n        <Nav>\n          <SearchBar onSearchVideos={e=>{\n            this.props.history.push(`/results?search_query=${e}`)\n            // this.props.updateQuery(v);//e.target.value\n          }\n          } />{/**e.target.value로 값으로 받아왔다. */}\n        </Nav>\n\n          <InfiniteScroll\n            // loadMore={() => this.getYoutubeData(this.props.query)}\n            hasMore={!!this.state.nextPageToken}\n            loader={\n              <div key={uuid.v4()} className=\"loader\">\n                <img src={spinner} alt=\"loading\" />\n              </div>\n            }\n          >\n            <VideoList\n              {...this.state}\n              onVideoSelect = {selectedVideo => this.props.history.push(`/watch?v=${selectedVideo}`)}\n            />\n\n          </InfiniteScroll>\n      </div>\n    );\n  }\n}\nfunction mapStateToprops(state){\n  return{\n    query:state.videos.query\n  }\n}\nfunction mapDispatchToProps(dispatch){\n  return bindActionCreators({//무조건 aciton에 있는 함수를 가져옴\n    updateQuery\n  },dispatch)\n}\nexport default withRouter(connect(mapStateToprops,mapDispatchToProps)(Main));//\n\n//history.push 이동하지않고 주소만 바뀌어보이는 것,브라우저 히스토리에 추가가 되기만 한다. 주소이동x\n//window.location.href 실제 이동 \n"]},"metadata":{},"sourceType":"module"}