import { Objectish, ObjectishNoSet } from "./types";
/** Use a class type for `nothing` so its type is unique */
export declare class Nothing {
    private _;
}
/**
 * The sentinel value returned by producers to replace the draft with undefined.
 */
export declare const NOTHING: Nothing;
/**
 * To let Immer treat your class instances as plain immutable objects
 * (albeit with a custom prototype), you must define either an instance property
 * or a static property on each of your custom classes.
 *
 * Otherwise, your class instance will never be drafted, which means it won't be
 * safe to mutate in a produce callback.
 */
export declare const DRAFTABLE: unique symbol;
export declare const DRAFT_STATE: unique symbol;
/** Returns true if the given value is an Immer draft */
export declare function isDraft(value: any): boolean;
/** Returns true if the given value can be drafted by Immer */
export declare function isDraftable(value: any): boolean;
export declare function isPlainObject(value: any): boolean;
/** Get the underlying object that is represented by the given draft */
export declare function original<T>(value: T): T | undefined;
export declare function assignSet(target: Map<any, any>, override: any): Map<any, any>;
export declare function assignMap(target: Map<any, any>, override: Map<any, any>): Map<any, any>;
export declare const assign: {
    <T, U>(target: T, source: U): T & U;
    <T_1, U_1, V>(target: T_1, source1: U_1, source2: V): T_1 & U_1 & V;
    <T_2, U_2, V_1, W>(target: T_2, source1: U_2, source2: V_1, source3: W): T_2 & U_2 & V_1 & W;
    (target: object, ...sources: any[]): any;
};
export declare const ownKeys: (target: any) => PropertyKey[];
export declare function shallowCopy<T extends Objectish>(base: T, invokeGetters?: boolean): T;
export declare function each<T extends Objectish>(obj: T, iter: (key: PropertyKey, value: any, source: T) => void): any;
export declare function isEnumerable(base: {}, prop: PropertyKey): boolean;
export declare function has(thing: ObjectishNoSet, prop: PropertyKey): boolean;
export declare function get(thing: ObjectishNoSet, prop: PropertyKey): any;
export declare function is(x: any, y: any): boolean;
export declare const hasSymbol: boolean;
export declare const hasMap: boolean;
export declare function isMap(target: any): target is Map<any, any>;
export declare const hasSet: boolean;
export declare function isSet(target: any): target is Set<any>;
export declare function makeIterable(next: () => {
    done: boolean;
    value: any;
}): {
    [Symbol.iterator]: () => any;
    next: () => {
        done: boolean;
        value: any;
    };
};
/** Map.prototype.values _-or-_ Map.prototype.entries */
export declare function iterateMapValues(state: any, prop: any, receiver: any): () => {
    [Symbol.iterator]: () => any;
    next: () => {
        done: boolean;
        value: any;
    };
};
export declare function makeIterateSetValues(createProxy: any): (state: any, prop?: any) => () => {
    [Symbol.iterator]: () => any;
    next: () => {
        done: boolean;
        value: any;
    };
};
export declare function clone<T extends Objectish>(obj: T): T;
export declare function freeze<T extends Objectish>(obj: T, deep?: boolean): void;
