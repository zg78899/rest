import { Nothing } from "./common";
export declare type Objectish = any[] | Map<any, any> | Set<any> | {};
export declare type ObjectishNoSet = any[] | Map<any, any> | {};
export interface ImmerState<T = any> {
    parent?: ImmerState;
    base: T;
    copy: T;
    assigned: {
        [prop: string]: boolean;
        [index: number]: boolean;
    };
}
declare type Tail<T extends any[]> = ((...t: T) => any) extends ((_: any, ...tail: infer TT) => any) ? TT : [];
/** Object types that should never be mapped */
declare type AtomicObject = Function | WeakMap<any, any> | WeakSet<any> | Promise<any> | Date | RegExp | Boolean | Number | String;
export declare type Draft<T> = T extends AtomicObject ? T : T extends Map<infer K, infer V> ? DraftMap<K, V> : T extends Set<infer V> ? DraftSet<V> : T extends object ? {
    -readonly [K in keyof T]: Draft<T[K]>;
} : T;
interface DraftMap<K, V> extends Map<Draft<K>, Draft<V>> {
}
interface DraftSet<V> extends Set<Draft<V>> {
}
/** Convert a mutable type into a readonly type */
export declare type Immutable<T> = T extends AtomicObject ? T : T extends Map<infer K, infer V> ? ImmutableMap<K, V> : T extends Set<infer V> ? ImmutableSet<V> : T extends object ? {
    readonly [K in keyof T]: Immutable<T[K]>;
} : T;
interface ImmutableMap<K, V> extends Map<Immutable<K>, Immutable<V>> {
}
interface ImmutableSet<V> extends Set<Immutable<V>> {
}
export interface Patch {
    op: "replace" | "remove" | "add";
    path: (string | number)[];
    value?: any;
}
export declare type PatchListener = (patches: Patch[], inversePatches: Patch[]) => void;
/** Converts `nothing` into `undefined` */
declare type FromNothing<T> = T extends Nothing ? undefined : T;
/** The inferred return type of `produce` */
export declare type Produced<Base, Return> = Return extends void ? Base : Return extends Promise<infer Result> ? Promise<Result extends void ? Base : FromNothing<Result>> : FromNothing<Return>;
/**
 * The `produce` function takes a value and a "recipe function" (whose
 * return value often depends on the base state). The recipe function is
 * free to mutate its first argument however it wants. All mutations are
 * only ever applied to a __copy__ of the base state.
 *
 * Pass only a function to create a "curried producer" which relieves you
 * from passing the recipe function every time.
 *
 * Only plain objects and arrays are made mutable. All other objects are
 * considered uncopyable.
 *
 * Note: This function is __bound__ to its `Immer` instance.
 *
 * @param {any} base - the initial state
 * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified
 * @param {Function} patchListener - optional function that will be called with all the patches produced here
 * @returns {any} a new state, or the initial state if nothing was modified
 */
export interface IProduce {
    /** Curried producer */
    <Recipe extends (...args: any[]) => any, Params extends any[] = Parameters<Recipe>, T = Params[0]>(recipe: Recipe): <Base extends Immutable<T>>(base: Base, ...rest: Tail<Params>) => Produced<Base, ReturnType<Recipe>>;
    /** Curried producer with initial state */
    <Recipe extends (...args: any[]) => any, Params extends any[] = Parameters<Recipe>, T = Params[0]>(recipe: Recipe, initialState: Immutable<T>): <Base extends Immutable<T>>(base?: Base, ...rest: Tail<Params>) => Produced<Base, ReturnType<Recipe>>;
    /** Normal producer */
    <Base, D = Draft<Base>, Return = void>(base: Base, recipe: (draft: D) => Return, listener?: PatchListener): Produced<Base, Return>;
}
/**
 * Like `produce`, but instead of just returning the new state,
 * a tuple is returned with [nextState, patches, inversePatches]
 *
 * Like produce, this function supports currying
 */
export interface IProduceWithPatches {
    /** Curried producer */
    <Recipe extends (...args: any[]) => any, Params extends any[] = Parameters<Recipe>, T = Params[0]>(recipe: Recipe): <Base extends Immutable<T>>(base: Base, ...rest: Tail<Params>) => [Produced<Base, ReturnType<Recipe>>, Patch[], Patch[]];
    /** Curried producer with initial state */
    <Recipe extends (...args: any[]) => any, Params extends any[] = Parameters<Recipe>, T = Params[0]>(recipe: Recipe, initialState: Immutable<T>): <Base extends Immutable<T>>(base?: Base, ...rest: Tail<Params>) => [Produced<Base, ReturnType<Recipe>>, Patch[], Patch[]];
    /** Normal producer */
    <Base, D = Draft<Base>, Return = void>(base: Base, recipe: (draft: D) => Return): [Produced<Base, Return>, Patch[], Patch[]];
}
export {};
