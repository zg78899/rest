{"ast":null,"code":"import _slicedToArray from \"/Users/pokeoseu/react-tutorial/begin-react/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"/Users/pokeoseu/react-tutorial/begin-react/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nvar _jsxFileName = \"/Users/pokeoseu/react-tutorial/begin-react/src/App.js\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React, { useRef, useReducer, useMemo, useCallback } from 'react';\nimport UserList from './UserList';\nimport CreateUser from './CreateUser';\nimport { statement } from '@babel/template';\n\nfunction countActiveUsers(users) {\n  console.log('활성사용자수를 세는 중..');\n  return users.filter(user => user.active).length;\n}\n\nconst initialState = {\n  inputs: {\n    username: '',\n    email: ''\n  },\n  users: [{\n    id: 1,\n    username: 'kim',\n    email: 'abx@naver.com',\n    active: true\n  }, {\n    id: 2,\n    username: 'park',\n    email: 'zxc@gmail.com',\n    active: true\n  }, {\n    id: 3,\n    username: 'lee',\n    email: 'zxczc@gmail.com',\n    active: false\n  }]\n};\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'CHANGE_INPUT':\n      return _objectSpread({}, state, {\n        inputs: _objectSpread({}, state.inputs, {\n          [action.name]: action.value\n        })\n      });\n\n    case 'CREATE_USER':\n      return {\n        inputs: initialState.inputs,\n        users: state.users.concat(action.user)\n      };\n\n    case 'TOGGLE_USER':\n      return _objectSpread({}, state, {\n        users: state.users.map(user => user.id === action.id ? _objectSpread({}, user, {\n          active: !user.active\n        }) : user)\n      });\n\n    case 'REMOVE_USER':\n      return _objectSpread({}, state, {\n        users: state.users.filter(user => user.id !== action.id) //일치하지않으면 유지하고 일치하면은 제거하겠다.\n\n      });\n\n    default:\n      throw new Error('Unhandeled action');\n  }\n}\n\nfunction App() {\n  const _useReducer = useReducer(reducer, initialState),\n        _useReducer2 = _slicedToArray(_useReducer, 2),\n        state = _useReducer2[0],\n        dispatch = _useReducer2[1];\n\n  const users = state.users;\n  const nextId = useRef(4);\n  const _state$inputs = state.inputs,\n        username = _state$inputs.username,\n        email = _state$inputs.email;\n  const onChange = useCallback(e => {\n    const _e$target = e.target,\n          name = _e$target.name,\n          value = _e$target.value;\n    dispatch({\n      type: 'CHANGE_INPUT',\n      name,\n      value\n    });\n  }, []);\n  const onCreate = useCallback(() => {\n    dispatch({\n      type: 'CREATE_USER',\n      user: {\n        id: nextId.current,\n        username,\n        email\n      }\n    });\n    nextId.current += 1;\n  }, [username, email]);\n  const onToggle = useCallback(id => {\n    dispatch({\n      type: 'TOGGLE_USER',\n      id\n    });\n  }, []); //컴포넌트를 만들때만 사용하고 계속해서 재사용을 할수있기 때문에 deps을 사용하지않아도 된다.\n\n  const onRemove = useCallback(id => {\n    dispatch({\n      type: 'REMOVE_USER',\n      id\n    });\n  }, []);\n  const count = useMemo(() => countActiveUsers(users), [users]);\n  return React.createElement(React.Fragment, null, React.createElement(CreateUser, {\n    username: username,\n    email: email,\n    onChange: onChange,\n    onCreate: onCreate,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 112\n    },\n    __self: this\n  }), React.createElement(UserList, {\n    users: users,\n    onToggle: onToggle,\n    onRemove: onRemove,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 118\n    },\n    __self: this\n  }), React.createElement(\"div\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 122\n    },\n    __self: this\n  }, \"\\uD65C\\uC131\\uC0AC\\uC6A9\\uC790\\uC758 \\uC218 : \", count));\n  /** return (\n  //   // <Counter />\n  // ) \n    // return (\n  //   <Wrapper>\n  //     <Hello name='react' color='red' isSpecial={true}/>// 기본값은 true이다.\n  //     <Hello color='pink' />\n  //   </Wrapper>\n    // )*/\n}\n\nexport default App; // import React, { useRef, useState ,useMemo,useCallback} from 'react';\n// import UserList from './UserList';\n// import CreateUser from './CreateUser';\n// function countActiveUsers(users) {\n//   console.log('활성사용자수를 세는 중..');\n//   return users.filter(user => user.active).length;\n// }\n// const initialStata={\n//   inputs:{\n//     username:'',\n//     email:'',\n//   },\n//   users:[\n//     {\n//       id: 1,\n//       username: 'kim',\n//       email: 'abx@naver.com',\n//       active: true,\n//     },\n//     {\n//       id: 2,\n//       username: 'park',\n//       email: 'zxc@gmail.com',\n//       active: true,\n//     },\n//     {\n//       id: 3,\n//       username: 'lee',\n//       email: 'zxczc@gmail.com',\n//       active: false,\n//     }\n//   ]\n// }\n// function App() {\n//   const [inputs, setInputs] = useState({\n//     username: '',\n//     email: '',\n//   });\n//   const { username, email } = inputs;\n//   const onChange =useCallback( e => {\n//     const { name, value } = e.target;\n//     setInputs({\n//       ...inputs,\n//       [name]: value /**여기서 name은 username와 email이다. */\n//     });\n//   },[inputs]);//onChange함수는 inputs가 바뀔때 에만 함수가 새로 만들어지고\n//   // 아닐때에는 이전의 값을 그대로 사용한다.\n//   const [users, setUsers] = useState([\n//     {\n//       id: 1,\n//       username: 'kim',\n//       email: 'abx@naver.com',\n//       active: true,\n//     },\n//     {\n//       id: 2,\n//       username: 'park',\n//       email: 'zxc@gmail.com',\n//       active: true,\n//     },\n//     {\n//       id: 3,\n//       username: 'lee',\n//       email: 'zxczc@gmail.com',\n//       active: false,\n//     }\n//   ]);\n//   /**push splice sort등은 원본 배열을 바꾸기 때문에 사용하지 않는것이 좋다. */\n//   /**spread 연산자를 사용하여 원본 배열을 복사한 후 사용한다. */\n//   const nextId = useRef(4);\n//   /** 이 값이 바뀔때 만다 굳이 rerender할 필요가 없기 때문에 useRef을 사용하여 변수로 관리를 함*/\n//   /**useRef는 특정 dom을 선택하고 싶을 때 사용할수있지만, 어떤한 변수를 기억하고 싶을때 ,rerendering되어도 계속 기억된다. */\n//   /**component가 rerender되어도 useRef(4)는 4 이다.*/\n//   const onCreate =useCallback( () => {\n//     const user = {\n//       id: nextId.current,\n//       username,\n//       email,\n//     };\n//     // setUsers([...users,user]);\n//     setUsers(users=>users.concat(user));\n//     //setUsers에 등록한 콜백함수의 파라미터 users에서 최신users을 조회하게 된다.\n//     //따라서  deps에 users을 제거해도된다.\n//     // 그렇게 되면 onCreate함수는 username과 email이 바뀔때에만 재렌더링이된다.\n//     /** concat함수를 사용한다. */\n//     setInputs({\n//       username: '',\n//       email: ''\n//     });\n//     console.log(nextId.current)//4\n//     nextId.current += 1; /** useRef의 값을 조회하여 바꾸게 되면 이값도 바뀌게 된다. 이 값이 바뀐다고 component가 rerender되지 않는다.*/\n//   },[username,email]);\n//   //useCallback내부에서 사용하는 상태 또는,props로 받는 값들이 있다면 모두deps에 넣어주어야한다.\n//   //[username,email,users];\n//   const onRemove = useCallback(id => {\n//     setUsers(users=>users.filter(user => user.id !== id));\n//   },[]); //onRemove함수는 컴포넌트가 만들어질때 딱한번만 만들고, 렌더링될때만 사용되고 이후에는 계속 전에있는 값만을 재사용한다.\n//   const onToggle = useCallback(id => {\n//     setUsers(users=>users.map(\n//       user => user.id === id ? { ...user, active: !user.active } : user\n//     ))\n//   },[]);\n//   const count =useMemo(()=>countActiveUsers(users),[users]);//이함수는 users가 바뀔때에만 호출되고 아닐때에는 이전에의 값을 그대로 사용한다.\n//   //useMemo를 사용하면 필요한 연산을 필요할때만 사용할수있다.\n//   //useMomo는 사용한 함수를 재사용할수있다.\n//   return (\n//     <>\n//       <CreateUser\n//         username={username}\n//         email={email}\n//         onChange={onChange}\n//         onCreate={onCreate} />\n//       <UserList users={users} ak={onRemove} onToggle={onToggle} />\n//       <div>활성사용자의 수 : {count}</div>\n//     </>\n//   )\n//   /** return (\n//   //   // <Counter />\n//   // ) \n//   // return (\n//   //   <Wrapper>\n//   //     <Hello name='react' color='red' isSpecial={true}/>// 기본값은 true이다.\n//   //     <Hello color='pink' />\n//   //   </Wrapper>\n//   // )*/\n// }\n// export default App;","map":{"version":3,"sources":["/Users/pokeoseu/react-tutorial/begin-react/src/App.js"],"names":["React","useRef","useReducer","useMemo","useCallback","UserList","CreateUser","statement","countActiveUsers","users","console","log","filter","user","active","length","initialState","inputs","username","email","id","reducer","state","action","type","name","value","concat","map","Error","App","dispatch","nextId","onChange","e","target","onCreate","current","onToggle","onRemove","count"],"mappings":"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","sourcesContent":["import React, { useRef, useReducer, useMemo, useCallback } from 'react';\nimport UserList from './UserList';\nimport CreateUser from './CreateUser';\nimport { statement } from '@babel/template';\n\n\nfunction countActiveUsers(users) {\n  console.log('활성사용자수를 세는 중..');\n  return users.filter(user => user.active).length;\n}\nconst initialState = {\n  inputs: {\n    username: '',\n    email: '',\n  },\n  users: [\n    {\n      id: 1,\n      username: 'kim',\n      email: 'abx@naver.com',\n      active: true,\n    },\n    {\n      id: 2,\n      username: 'park',\n      email: 'zxc@gmail.com',\n      active: true,\n    },\n    {\n      id: 3,\n      username: 'lee',\n      email: 'zxczc@gmail.com',\n      active: false,\n    }\n  ]\n}\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'CHANGE_INPUT':\n      return {\n        ...state,\n        inputs: {\n          ...state.inputs,\n          [action.name]: action.value\n        }\n      };\n    case 'CREATE_USER':\n      return {\n        inputs: initialState.inputs,\n        users: state.users.concat(action.user)\n\n      }\n    case 'TOGGLE_USER':\n      return {\n        ...state,\n        users: state.users.map(\n          user => user.id === action.id ? { ...user, active: !user.active } : user)\n      }\n    case 'REMOVE_USER':\n      return {\n        ...state,\n        users: state.users.filter(\n          user => user.id !== action.id)  //일치하지않으면 유지하고 일치하면은 제거하겠다.\n      }\n    default:\n      throw new Error('Unhandeled action');\n  }\n}\nfunction App() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  const { users } = state;\n  const nextId = useRef(4);\n  const { username, email } = state.inputs;\n\n  const onChange = useCallback(e => {\n    const { name, value } = e.target;\n    dispatch({\n      type: 'CHANGE_INPUT',\n      name,\n      value\n    })\n  }, []);\n  const onCreate = useCallback(() => {\n    dispatch({\n      type: 'CREATE_USER',\n      user: {\n        id: nextId.current,\n        username,\n        email,\n      }\n    });\n    nextId.current += 1;\n\n  }, [username, email]);\n\n  const onToggle = useCallback((id) => {\n    dispatch({\n      type: 'TOGGLE_USER',\n      id\n    })\n  }, []);//컴포넌트를 만들때만 사용하고 계속해서 재사용을 할수있기 때문에 deps을 사용하지않아도 된다.\n  const onRemove = useCallback(id => {\n    dispatch({\n      type: 'REMOVE_USER',\n      id\n    })\n  }, []);\nconst count=useMemo(()=>countActiveUsers(users),[users]);\n\n  return (\n    <>\n      <CreateUser\n        username={username}\n        email={email}\n        onChange={onChange}\n        onCreate={onCreate}\n      />\n      <UserList\n        users={users}\n        onToggle={onToggle}\n        onRemove={onRemove} />\n      <div>활성사용자의 수 : {count}</div>\n    </>\n  )\n\n  /** return (\n  //   // <Counter />\n  // ) \n \n  // return (\n  //   <Wrapper>\n  //     <Hello name='react' color='red' isSpecial={true}/>// 기본값은 true이다.\n  //     <Hello color='pink' />\n  //   </Wrapper>\n\n\n  // )*/\n}\n\nexport default App;\n\n// import React, { useRef, useState ,useMemo,useCallback} from 'react';\n// import UserList from './UserList';\n// import CreateUser from './CreateUser';\n\n\n// function countActiveUsers(users) {\n//   console.log('활성사용자수를 세는 중..');\n//   return users.filter(user => user.active).length;\n// }\n// const initialStata={\n//   inputs:{\n//     username:'',\n//     email:'',\n//   },\n//   users:[\n//     {\n//       id: 1,\n//       username: 'kim',\n//       email: 'abx@naver.com',\n//       active: true,\n//     },\n//     {\n//       id: 2,\n//       username: 'park',\n//       email: 'zxc@gmail.com',\n//       active: true,\n//     },\n//     {\n//       id: 3,\n//       username: 'lee',\n//       email: 'zxczc@gmail.com',\n//       active: false,\n//     }\n//   ]\n\n// }\n// function App() {\n//   const [inputs, setInputs] = useState({\n//     username: '',\n//     email: '',\n//   });\n//   const { username, email } = inputs;\n//   const onChange =useCallback( e => {\n//     const { name, value } = e.target;\n//     setInputs({\n//       ...inputs,\n//       [name]: value /**여기서 name은 username와 email이다. */\n//     });\n//   },[inputs]);//onChange함수는 inputs가 바뀔때 에만 함수가 새로 만들어지고\n//   // 아닐때에는 이전의 값을 그대로 사용한다.\n\n//   const [users, setUsers] = useState([\n//     {\n//       id: 1,\n//       username: 'kim',\n//       email: 'abx@naver.com',\n//       active: true,\n//     },\n//     {\n//       id: 2,\n//       username: 'park',\n//       email: 'zxc@gmail.com',\n//       active: true,\n//     },\n//     {\n//       id: 3,\n//       username: 'lee',\n//       email: 'zxczc@gmail.com',\n//       active: false,\n//     }\n//   ]);\n\n//   /**push splice sort등은 원본 배열을 바꾸기 때문에 사용하지 않는것이 좋다. */\n//   /**spread 연산자를 사용하여 원본 배열을 복사한 후 사용한다. */\n\n\n//   const nextId = useRef(4);\n//   /** 이 값이 바뀔때 만다 굳이 rerender할 필요가 없기 때문에 useRef을 사용하여 변수로 관리를 함*/\n//   /**useRef는 특정 dom을 선택하고 싶을 때 사용할수있지만, 어떤한 변수를 기억하고 싶을때 ,rerendering되어도 계속 기억된다. */\n//   /**component가 rerender되어도 useRef(4)는 4 이다.*/\n//   const onCreate =useCallback( () => {\n//     const user = {\n//       id: nextId.current,\n//       username,\n//       email,\n\n//     };\n//     // setUsers([...users,user]);\n//     setUsers(users=>users.concat(user));\n//     //setUsers에 등록한 콜백함수의 파라미터 users에서 최신users을 조회하게 된다.\n//     //따라서  deps에 users을 제거해도된다.\n//     // 그렇게 되면 onCreate함수는 username과 email이 바뀔때에만 재렌더링이된다.\n//     /** concat함수를 사용한다. */\n//     setInputs({\n//       username: '',\n//       email: ''\n//     });\n//     console.log(nextId.current)//4\n//     nextId.current += 1; /** useRef의 값을 조회하여 바꾸게 되면 이값도 바뀌게 된다. 이 값이 바뀐다고 component가 rerender되지 않는다.*/\n//   },[username,email]);\n//   //useCallback내부에서 사용하는 상태 또는,props로 받는 값들이 있다면 모두deps에 넣어주어야한다.\n//   //[username,email,users];\n\n//   const onRemove = useCallback(id => {\n//     setUsers(users=>users.filter(user => user.id !== id));\n//   },[]); //onRemove함수는 컴포넌트가 만들어질때 딱한번만 만들고, 렌더링될때만 사용되고 이후에는 계속 전에있는 값만을 재사용한다.\n\n//   const onToggle = useCallback(id => {\n//     setUsers(users=>users.map(\n//       user => user.id === id ? { ...user, active: !user.active } : user\n//     ))\n//   },[]);\n\n//   const count =useMemo(()=>countActiveUsers(users),[users]);//이함수는 users가 바뀔때에만 호출되고 아닐때에는 이전에의 값을 그대로 사용한다.\n//   //useMemo를 사용하면 필요한 연산을 필요할때만 사용할수있다.\n//   //useMomo는 사용한 함수를 재사용할수있다.\n//   return (\n//     <>\n//       <CreateUser\n//         username={username}\n//         email={email}\n//         onChange={onChange}\n//         onCreate={onCreate} />\n//       <UserList users={users} ak={onRemove} onToggle={onToggle} />\n//       <div>활성사용자의 수 : {count}</div>\n//     </>\n//   )\n\n//   /** return (\n//   //   // <Counter />\n//   // ) \n\n//   // return (\n//   //   <Wrapper>\n//   //     <Hello name='react' color='red' isSpecial={true}/>// 기본값은 true이다.\n//   //     <Hello color='pink' />\n//   //   </Wrapper>\n\n\n//   // )*/\n// }\n\n// export default App;\n"]},"metadata":{},"sourceType":"module"}